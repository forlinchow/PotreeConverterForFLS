#pragma once

#import "iQOpen.dll" no_namespace
#include <string>
#include "tinyply.h"
#include <iostream>
#include <fstream>

class plyWriter
{
public:
	plyWriter() {}
	~plyWriter() {}

	int convert(std::string fileFLS, int scan_dis)
	{
		//if (argc < 2)
		//{

		//	FILE* fp = fopen("log.txt", "w");
		//	fprintf(fp, "error \n argc: ", argc);
		//	std::cout << "Error " << argc << std::endl;
		//	return (-1);
		//}

		//std::string folderName = "GD_huangpu_htt_007.fls";

		std::cout << "reading FLS: " << fileFLS << std::endl;
		CoInitialize(NULL);
		// 以下liscence需要整段输入，key放入liscence key
		BSTR licenseCode =
			L"FARO Open Runtime License\n"
			L"Key:W2CW4PNRTCTXXJ6T6KXYSRUPL\n" // License Key
			L"\n"
			L"The software is the registered property of "
			L"FARO Scanner Production GmbH, Stuttgart, Germany.\n"
			L"All rights reserved.\n"
			L"This software may only be used with written permission "
			L"of FARO Scanner Production GmbH, Stuttgart, Germany.";
		IiQLicensedInterfaceIfPtr liPtr(__uuidof(iQLibIf));
		liPtr->License = licenseCode;
		IiQLibIfPtr libRef = static_cast<IiQLibIfPtr>(liPtr);//点云数据IO
		std::cout << "loading FLS: " << fileFLS << std::endl;
		if (libRef->load(fileFLS.c_str()) != 0) {
			std::cout << "loading fls error " << std::endl;
			return -1;
		}//加载数据
		std::cout << "loading success " << std::endl;
		IiQObjectIfPtr libObj = libRef->getScanObject(0);
		IiQScanObjIfPtr scanRef = libObj->getScanObjSpecificIf();//法如扫描属性IO
		scanRef->load();//加载属性

		double x, y, z, angle;

		// 扫描原点
		if (libRef->getScanPosition(0, &x, &y, &z) != 0) {
			std::cout << "loading points error " << std::endl;
			return -1;
		}

		int rows = libRef->getScanNumRows(0);
		int cols = libRef->getScanNumCols(0);

		if (libRef->getScanOrientation(0, &x, &y, &z, &angle) != 0) {
			std::cout << "getScanOrientation error " << std::endl;
			return -1;
		}
		// 由文档公式得
		double ca = cos(-angle);
		double sa = sin(-angle);
		// 变换矩阵
		double R[3][3];
		R[0][0] = x * x * (1 - ca) + ca;
		R[0][1] = y * x * (1 - ca) - z * sa;
		R[0][2] = z * x * (1 - ca) + y * sa;
		R[1][0] = x * y * (1 - ca) + z * sa;
		R[1][1] = y * y * (1 - ca) + ca;
		R[1][2] = z * y * (1 - ca) - x * sa;
		R[2][0] = x * z * (1 - ca) - y * sa;
		R[2][1] = y * z * (1 - ca) + x * sa;
		R[2][2] = z * z * (1 - ca) + ca;

		//fprintf(fp, "size : %d %d  \n", rows, cols);
		int refl;
		int result;

		std::vector<float> verts;
		double xx, yy, zz;
		//int scan_dis = std::atoi(argv[3]);
		for (int row = 0; row < rows; row += 10)
		{
			int scale = 1.0 / (std::pow((1.0 - std::abs(row - rows / 2.0) / (rows / 2.0)), 4.0) + 0.0001);
			for (int col = 0; col < cols; col += (scale + 10)) {
				result = libRef->getScanPoint(0, row, col, &x, &y, &z, &refl);     // 读取数据,x,y,z 点坐标， refl为反射值
				if (x == 0 & y == 0 & z == 0)
				{
					continue;
				}
				xx = x*R[0][0] + y*R[1][0] + z*R[2][0];
				yy = x*R[0][1] + y*R[1][1] + z*R[2][1];
				zz = x*R[0][2] + y*R[1][2] + z*R[2][2];
				if (zz >= 0.2 || zz <= -0.2) {
					continue;
				}
				if (std::pow(xx*xx + yy*yy + zz*zz, 0.5) > scan_dis)
				{
					continue;
				}

				verts.push_back(xx);
				verts.push_back(yy);
				verts.push_back(zz);
			}

		}
		tinyply::PlyFile myFile;
		myFile.add_properties_to_element("vertex", { "x", "y", "z" }, verts);
		myFile.comments.push_back("generated by FYtech");
		std::filebuf fb;
		std::cout << "create ply " << std::endl;
		fb.open(fileFLS, std::ios::out | std::ios::binary);
		std::ostream outputStream(&fb);
		std::cout << "write ply: " << fileFLS << std::endl;
		myFile.write(outputStream, true);
		fb.close();
		// free

		std::cout << "Write Done: " << fileFLS << std::endl;
		libRef = NULL;
		libObj = NULL;
		scanRef = NULL;
		liPtr = NULL;
		CoUninitialize();
		return 0;
	}

};